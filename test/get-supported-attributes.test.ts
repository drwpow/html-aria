import { describe, expect, test } from 'vitest';
import {
  type ARIAAttribute,
  attributes,
  getSupportedAttributes,
  globalAttributes,
  isSupportedAttribute,
  isValidAttributeValue,
  namingProhibited,
  roles,
  tags,
} from '../src/index.js';
import { checkTestAndTagName } from './helpers.js';

const GLOBAL_ATTRIBUTES = Object.keys(globalAttributes) as ARIAAttribute[];
const GLOBAL_NO_NAMING = namingProhibited(GLOBAL_ATTRIBUTES);

// Note: these tests are the most difficult to write. To not make them circular,
// it’s worth describing where the data came from.
//
// - The data in lib/aria-roles.ts and lib/aria-attributes.ts
//   were generated by scraping the W3C spec.
// - The data in lib/html.ts was manually written by reading this
//   spec: https://www.w3.org/TR/html-aria. So of the two, it’s the more-likely
//   to be error-prone
//
// So to keep these tests, while having some sort of assurance they’re not
// useless, we try and assemble the same attribute list by other means.
//
// **Exmmple**
// According to the spec, <body> combines “global attributes allowed for the `generic`
// role, minus `aria-hidden`. That has been flattened in lib/html.ts for perf,
// but there may be an error. So we recreate that list by following th espec, and
// just filtering out "aria-hidden" from generic attributes. And we get a perfect match!
//
// The important thing is to:
// 1. Read the spec for a given element
// 2. Try and recreate that list here, ideally following a different code path
// 3. Examine the difference in output, if any, and determine where the mistake is.
//
// By following all these steps, we have more confidence the data is correct by double-
// checking it using different means. And it also doubles as a snapshot to notify
// us if the data changed anywhere..
const tests: [
  string,
  { given: Parameters<typeof getSupportedAttributes>; want: ReturnType<typeof getSupportedAttributes> },
][] = [
  ['a', { given: [{ tagName: 'a' }], want: [...GLOBAL_ATTRIBUTES, ...roles.link.supported] }],
  ['area', { given: [{ tagName: 'area' }], want: [...GLOBAL_ATTRIBUTES, ...roles.link.supported] }],
  ['abbr', { given: [{ tagName: 'abbr' }], want: [...GLOBAL_NO_NAMING] }],
  ['base', { given: [{ tagName: 'base' }], want: [] }],
  [
    'body',
    {
      given: [{ tagName: 'body' }],
      want: [...namingProhibited(roles.generic.supported).filter((a) => a !== 'aria-hidden')],
    },
  ],
  ['col', { given: [{ tagName: 'col' }], want: [] }],
  ['colgroup', { given: [{ tagName: 'colgroup' }], want: [] }],
  ['head', { given: [{ tagName: 'head' }], want: [] }],
  ['html', { given: [{ tagName: 'html' }], want: [] }],
  ['meta', { given: [{ tagName: 'meta' }], want: [] }],
  ['slot', { given: [{ tagName: 'slot' }], want: [] }],
  ['style', { given: [{ tagName: 'style' }], want: [] }],
  ['track', { given: [{ tagName: 'track' }], want: [] }],
];

describe('getSupportedAttributes', () => {
  const testedTags = new Set<string>();

  test.each(tests)('%s', (name, { given, want }) => {
    checkTestAndTagName(name, given[0].tagName);
    testedTags.add(given[0].tagName);

    const wantSorted = [...new Set(want)].sort((a, b) => a.localeCompare(b));
    expect(getSupportedAttributes(...given)).toEqual(wantSorted);
  });

  test('all tags are tested', () => {
    const missingTags = Object.keys(tags).filter((tag) => !testedTags.has(tag));
    expect(missingTags).toEqual([]);
  });
});

describe('isSupportedAttribute', () => {
  const allAttributes = Object.keys(attributes) as ARIAAttribute[];
  allAttributes.sort((a, b) => a.localeCompare(b));
  for (const [name, { given, want }] of tests) {
    describe(name, () => {
      for (const attr of allAttributes) {
        test(attr, () => {
          expect(isSupportedAttribute(attr, ...given)).toBe(want.includes(attr));
        });
      }
    });
  }
});

const valueTests: [
  string,
  {
    given: Parameters<typeof isValidAttributeValue>;
    want: ReturnType<typeof isValidAttributeValue>;
  },
][] = [
  // enum
  ['aria-checked="true"', { given: ['aria-checked', 'true'], want: true }],
  ['aria-checked="false"', { given: ['aria-checked', 'false'], want: true }],
  ['aria-checked="mixed"', { given: ['aria-checked', 'mixed'], want: true }],
  ['aria-checked={true}', { given: ['aria-checked', true], want: true }],
  ['aria-checked={false}', { given: ['aria-checked', false], want: true }],
  ['aria-checked=""', { given: ['aria-checked', ''], want: false }], // acceptable for boolean, but this is an enum!
  ['aria-checked="?"', { given: ['aria-checked', undefined], want: false }], // "undefined" is a valid value, however, this method assumes presence of an attribute (undefined is absence)
  ['aria-checked="foobar"', { given: ['aria-checked', 'foobar'], want: false }],

  // boolean
  ['aria-disabled="true"', { given: ['aria-disabled', 'true'], want: true }],
  ['aria-disabled="false"', { given: ['aria-disabled', 'false'], want: true }],
  ['aria-disabled={true}', { given: ['aria-disabled', true], want: true }],
  ['aria-disabled={false}', { given: ['aria-disabled', false], want: true }],
  ['aria-disabled=""', { given: ['aria-disabled', ''], want: true }],
  ['aria-disabled="foobar"', { given: ['aria-disabled', 'foobar'], want: false }],
];

describe('isValidAttributeValue', () => {
  test.each(valueTests)('%s', (_, { given, want }) => {
    expect(isValidAttributeValue(...given)).toBe(want);
  });
});
